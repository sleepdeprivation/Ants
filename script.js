
/*
	Put a solid object down somewhere
*/
function placeRect(map, startX, endX, startY, endY, value){
	for(var ii = startX; ii < endX; ii++){
		for(var kk = startY; kk < endX; kk++){
			map.arr[ii][kk] = true;
		}
	}
}

/*
	Runs the whole show
*/
function Simulation(sizeX, sizeY){

	//maximum 1000 ants
	this.antlist = new queue(1000);
	//this.pathlist = new PathMap(sizeX, 16);
	
	//the current scent trail manager -- we'll see how long it lasts
	this.pathman = new PathManager(sizeX, sizeY);

	//how big is the map
	this.dimension = new Point(sizeX, sizeY);
	
	//where will the ants be spawning
	this.origin = new Point(sizeX/2, sizeY/2);

	//this is the map
	this.map = new XYArray(sizeX, sizeY, false);
	
	//put a big solid object down
	placeRect(this.map, this.origin.x-80, this.origin.x-50, this.origin.y, this.origin.y+50);
	
	
	
	this.forageCheck = function(ant){
		//check if this ant is near the origin, if it is, switch it to foraging mode
		//(this way, ants that come back with food will turn around and do it again)
		if(	ant.location.x > this.origin.x-3 &&
			ant.location.x < this.origin.x+3
			&&
			ant.location.y > this.origin.y-3 &&
			ant.location.y < this.origin.y+3
		){
			ant.foraging = true;
		}
	}
	
	this.deathCheck = function(ant){
		//this ant is dead... this should probably happen first?
		if(ant.health <= 0){
			if(! ant.foraging){	//drop the food
				food = new Food(new Point(ant.location.x, ant.location.y));
				food.size = 3;
				this.food.push(food);
			}
				//delete ant;	doesn't do what you think it does, apparently
				//ii++;
			}else{
				this.antlist.push(ant);
			}
	}
	
	this.updateAnt = function(ant, suggestion){
		//let the ant move
		ant.update(suggestion, this.map);
		if(ant.foraging){
			//this.pathman.add(new Path(loc.x, loc.y, ant.orientation));
		}else{
			this.pathman.add(new Path(ant.location.x, ant.location.y, ant.orientation + Math.PI));
		}
	}
	
	this.manageFood0 = function(){
		//food[0] is generated by this system, the rest of the food is left alone
		if(this.food.length == 0 || this.food[0].size <=5){
			this.food[0] = (new Food(new Point(
						rng(this.origin.x-200, this.origin.x+200),
						rng(this.origin.y-200, this.origin.y+200)
						)
					)
					);
		}
	}
	
	this.makeSuggestion = function(ant){
		//make a suggestion based on scent trails or food location
		var suggestion;
		if(ant.foraging){
			suggestion = this.pathman.get(ant.location.x, ant.location.y);
		}else{
			var dx = this.origin.x-ant.location.x;
			var dy = this.origin.y-ant.location.y;
			suggestion = Math.atan(dy/dx);
			if(dx < 0){
				suggestion += Math.PI;
			}
		}
		return suggestion;
	}
	
	this.pickupNearbyFood = function(ant){
		//check if this ant can pick up any nearby food (if it's looking to do so)
		for(var kk = 0; kk < this.food.length; kk++){
			if(	ant.foraging					&&
				ant.location.x > this.food[kk].location.x	&&
				ant.location.x < this.food[kk].location.x+this.food[kk].size
					&&
				ant.location.y > this.food[kk].location.y	&&
				ant.location.y < this.food[kk].location.y+this.food[kk].size
			){
				this.food[kk].size--;
				this.food[kk].location.x++;
				this.food[kk].location.y++;
				ant.foraging = false;
					//ant.food +=1;
			}
		}	
	}
	
	this.randomScentTrailDecay = function(){
		//randomly destroy scent trails (1 in 8000 chance)
		var loc;
		for(var ii = 0; ii < this.pathman.list.length; ii++){
			loc = this.pathman.list[ii].location;
			if(rng(0, 8000) == 0){
				this.pathman.grid.arr[Math.floor(loc.x)][Math.floor(loc.y)] = null;
			}
		}
	}
	
	this.removeSmallFood = function(){
		//except if it's too small, then it disappears
		for(var ii = 0; ii < this.food.length; ii++){
			if(this.food[ii].size < 3){
				this.food[ii] = this.food[this.food.length-1];
				this.food.pop();
			}
		}
	}

	//make 1 ant to start
	this.init = function(){
		this.antlist.push(Ant(this.origin));
	}

	//generate an ant and return it
	this.makeAnt = function(where){
		return new Ant(this.origin, this.sizeX, this.sizeY);
	}

	/*
		Get a square of points with size 2*size centered at the point <where>
		return all the points
	*/
	this.adjacencySquare = function(where, size){
		floored = new Point(Math.floor(where.x), Math.floor(where.y));
		retlist = [];
		//more fun than writing out retlist.push 6 times
		for(var ii = -size; ii <= size; ii++){
			for(var kk = -size; kk <= size; kk++){
				if(ii != 0 || kk !=0){
					retlist.push(new Point(floored.x + ii, floored.y + kk));
				}
			}
		}
		return retlist;
	}

	//return the nearest neighbors of point <where>
	this.adjacencyList = function(where){
		return this.adjacencySquare(where, 1);
	}

	//no food around
	this.food = [];

	/*
		generate an ant
		manage the food on map
		manage ant movements
		
	*/
	this.update = function(){
		if(rng(0, 2) == 1){
			this.antlist.push(this.makeAnt());
			//console.log("made");
			//console.log(this.antlist);
		}
		
		this.manageFood0();
		this.removeSmallFood();

		//let the ants move
		var ant,loc,food;
		for(var ii = 0; ii < this.antlist.currentSize; ii++){
			ant = this.antlist.pop();
			if(ant == null){continue;}
			this.pickupNearbyFood(ant);
			this.forageCheck(ant);
			var suggestion = this.makeSuggestion(ant);
			this.updateAnt(ant, suggestion);
			this.deathCheck(ant);
		}
		
		this.randomScentTrailDecay();


	}

}
